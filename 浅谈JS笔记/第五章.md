# 嵌套函数及闭包

## 嵌套函数

js的函数是通过词法来划分作用域的，所以函数是在定义它们的作用域中运行，而不是执行它们的作用域中运行。

> 词法作用域：
>
> 词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。

```javascript
var x = 'global';
function f () {
  var x = 'local';
  function g() {
    alert(x);
  }
  g();
}
f(); // 'local'
```

> 作用域链：
>
> 当前作用域 => 上层作用域=>... =>全局作用域

- 调用f()：

  - 作用域链可以理解为由两部分组成： 调用f的调用对象、全局对象。
  - 此时查找 x 的值，会先从 f 的调用对象中查找，如果没有，再查找后面全局对象中 x。

- 调用g()：

  > g 是 f 的一个嵌套函数

  - 作用域链应该就是由三部分组成:g 的调用对象 、f 的调用对象、全局对象。
  - 要输出 x 的值，会先在 g 的调用对象中查找 x 的值，g 中没有定义，接下来查找外围 f 调用对象中 x 的定义，找到了 x='local'，那么就会输出 x，而不会继续往下查找全局对象了。 如果 f 中也没定义 x 的值，那么就会继续查找作用域链后面的全局对象，结果就是 global 了。
  - 如果全局对象中也没定义，那么自然就是 undefined。

## 闭包

***闭包***是由函数以及声明该函数的词法环境组合而成的。

### 特性

- 函数嵌套函数
- 函数内部可以引用函数外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

### 两种主要形式

- 函数作为返回值
- 闭包作为参数传递

### 用途

> - 访问到局部变量
>
> - 把外围作用域中的变量值存储在内存中而不在函数调用完毕后就销毁
>
>   > 这个用途也可能造成消耗内存的缺点

#### 理解第一个用途

```javascript
function a(){
  var name='Jeren';
  return function(){return name;}
}
var b = a();
console.log(b());//Jeren
```

这里就实现了全局变量下访问到局部变量。

#### 理解第二个用途

```javascript
function makeFunc (x) {
  return function () {return x++}
}
var a = [makeFunc(0), makeFunc(1), makeFunc(2)];
alert(a[0]());
alert(a[1]());
alert(a[2]());
```

- `makeFunc` 每次调用的时候，会为他创建一个调用对象放置到作用域链中。这个调用对象包含一个属性 `x`（即函数的参数）。

- 然后`makeFunc` 会返回一个匿名嵌套函数的引用，这个匿名嵌套函数执行，又会创建一个调用对象，放置到作用域链中，匿名函数返回` x` 的值，然后 `x` 加 1。

  > 注意：匿名函数的调用对象中是没有 `x` 的定义的，于是它会引用到它的上层作用域中。
  >
  > 匿名函数的实例维持了一个对它的词法环境（变量 `x` 存在于其中）的引用。所以上层作用域中的函数调用对象虽然在函数执行完毕之后就被销毁了，但是其变量x依然可以被访问。

- 匿名函数执行完毕，它的调用对象从作用域链中移除， 然后 `makeFunc`也执行完毕，`makeFunc` 调用对象也被移除，` x` 也随着它的销毁而销毁。

若将以上代码块做如下改动：

```javascript
var x = 0;
function makeFunc () {
  return function () {return x++}
}
//其余不变
```

虽然执行结果不变，但是从作用域链角度理解就不同了。由于x变成了全局变量，每一次对函数`makeFunc`及内嵌函数调用执行完毕后，其调用对象的销毁并不会影响到`x`，故每一次的执行结果都被保存了下来。

**场景：**

有时候需要写一个需要通过调用来记住一个变量值的函数。

> 要记住一个变量值，通过局部变量是很难做到的，因为函数的调用对象不能在调用后一直维持。
>
> 全局变量虽然可以，但是容易造成全局污染。

怎么解决呢？**不把值保存在调用对象中！**

一种实现方法：**用函数对象自身的属性来保存。**

```javascript
uniqueID = function () {
  if (!arguments.callee.id) 
    arguments.callee.id = 0;
  return arguments.callee.id ++;
}
alert(uniqueID()); //0
alert(uniqueID()); //1
```

这么做可行的原因是函数本身就是一个对象，但是有一个问题是任何人都可以强制访问到我们保存的值并作出修改。

另外一种方法：**闭包！**

```javascript
_uniqueID = (function(){
  var id = 0;
  return function () {return id ++}
})();
alert(_uniqueID()); //0
alert(_uniqueID()); //1
```

这里`_uniqueID`是函数表达式的声明方式，并且因为在其后加上了`()`，所以在赋值完后会自动执行一次，这是`_uniqueID`实际上已经是匿名函数`function () {return id ++}`。

这里外围匿名函数虽然在执行完毕后已经被销毁，但是其内部变量`id`依然被保存在内存中，因为能够访问到它的函数调用对象还在。

### 循环闭包中的一个常见错误

```javascript
//期望依次输出0，1，2
var b = [];

for(var i=0;i<3;i++){
    b.push(function(){console.log(i)})
}
b[0]()//3
b[1]()//3
b[2]()//3
```

原因是`push`到`b`的都是闭包，而这些闭包是由它们的函数定义以及`for`循环的所捕获的作用域所组成的，它们贡献了同一个词法作用域，它们所引用到的`i`是同一个变量。所以每次循环`i`的变化也就共享到了`b`每一个元素。所以最后在调用这些闭包的时候，循环早已经结束，所以的`i`都是3。

**如何解决？**

方法之一是使用`ES2015`引入的`let`关键字和块作用域的概念。

```javascript
//期望依次输出0，1，2
var b = [];

for(let i=0;i<3;i++){
    b.push(function(){console.log(i)})
}
b[0]()//0
b[1]()//1
b[2]()//2
```

其他方法可参见[`Mozilla`官方文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)：如引入更多闭包等

