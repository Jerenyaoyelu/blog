在通读官方文档的列表渲染部分时，遇到了“就地更新”策略，读了几遍之后，发现还是不是很好理解，故自己有上网搜了一下，做了这个笔记。

关于“就地更新”策略，官方文档的表述如下：

```
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。
```

难理解点在于“就地更新每个元素，并且确保它们在每个索引位置正确渲染”。这里的就地更新是指把当前这个元素直接更新为变更顺序后这个索引位置上的元素呢？还是因为只是变更了顺序，这个元素还是存在的，故保留这个元素在这个位置上，那么它更新的又是什么呢？

这句话并不能给人很直观的感受。我是一个直观生物，所以实在理解不了。

在看了[知乎上一片博客](https://www.zhihu.com/question/61078310)之后，突然联想到在 Vue 的官方文档的条件渲染中也有一段对 Vue 的”复用“策略的解释：

```
Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：
```

```vue
<template v-if="loginType === 'username'">
	<label>Username</label>
	<input placeholder="Enter your username" />
</template>
<template v-else>
	<label>Email</label>
	<input placeholder="Enter your email address" />
</template>
```

```
那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<input> 不会被替换掉——仅仅是替换了它的 placeholder。
```

这里的效果是在当登陆类型发生变化时，vue用重复利用相同的`label`,`input`元素，只是更改对应的数据，比如从“Username”变为“Email”，`placeholder`从“Enter your username"变为"Enter your email address"。



那么这里的”就地更新“策略应该也就只是利用了Vue中默认的”复用“策略，因为是列表渲染，故所有的元素都是一致的，因此Vue不会去销毁原有的元素然后重新渲染新元素，而只是相应的更新对应的数据。

也正因此，官方文档又说明道：

```
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
```

因为表单输入值这些还是会保留在input元素里，由于本质的input并没有被销毁改变，所以当顺序变化时，根据“复用”策略相应的数据改变了，但是用户输入的值依然保留着，也就造成了知乎上这篇博客所举的例子。依赖子组件状态的情况也是如此。

所以官方文档在后面建议道：

```
建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
```

